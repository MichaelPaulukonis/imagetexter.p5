{"version":3,"sources":["webpack:///bundle.fc8713a26ddc455495c5.js","webpack:///./src/sketch/TextManager.js","webpack:///./src/sketch/sketch.js","webpack:///./src/index.js","webpack:///./src/sketch/undo.js"],"names":["webpackJsonp","23","module","exports","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","TextManager","text","this","words","charIndex","wordIndex","self","getchar","c","w","charAt","length","getcharRandom","Math","floor","random","getWord","word","getText","setText","split","RegExp","default","24","Sketch","p5","textManager","getBodyCopy","textInputBox","setBodyCopy","paintWordAtPoint","locX","locY","randomSizeMode","spatterWordAtPoint","paintStaticSizedWordAtPoint","offX","getJitter","offY","setFill","origTextSize","textsize","textSize","randomTextSize","prevSize","offset","newsize","clearScreen","field","blackNotWhite","whitefield","blackfield","background","changeTextsize","direction","getRandomInt","jitRange","setJitRange","setImage","image","img","loadImage","imageReady","paintGrid","textAlign","LEFT","BOTTOM","nextX","nextY","yOffset","textAscent","textDescent","width","height","textWidth","CENTER","nextPaintMode","curPaintMode","paintModes","fill","sx","sy","pix","drawingContext","getImageData","data","toggleAutoPaintMode","autoPaintMode","autoPaintRegion","minX","minY","maxX","maxY","toggleRandomSizeMode","save","filename","frameCount","saveFrame","console","log","keyHandler","char","mouseX","mouseY","DELETE","BACKSPACE","gotFile","file","type","println","bodycopy","document","getElementById","setup","canvas","createCanvas","parent","drop","addEventListener","frameRate","draw","mouseIsPressed","mouseInCanvas","resize","loadPixels","min","max","keyPressed","keyPresser","keyCode","keyTyped","key","UP_ARROW","DOWN_ARROW","RIGHT_ARROW","LEFT_ARROW","_undo","obj","__esModule","44","_interopRequireDefault","builder","p","myP5","t","_p","_p2","_TextManager","_TextManager2","_sketch","_sketch2","P5","45","Undo","levels","undoSteps","redoSteps","images","CircImgCollection","takeSnapshot","amount","next","capture","undo","prev","show","redo","amountOfImages","current","i","createImage","get","46","47"],"mappings":"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","file":"bundle.fc8713a26ddc455495c5.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 23:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TextManager = function TextManager(text) {\n  _classCallCheck(this, TextManager);\n\n  var defaultText = 'These are the pearls that were his eyes';\n  var SPLIT_TOKENS = '[ ?.,;:<>()\"]';\n  var words = [];\n  var charIndex = 0;\n  var wordIndex = 0;\n  var self = this;\n  self.getchar = function () {\n    var c = self.w.charAt(charIndex);\n    charIndex = (charIndex + 1) % self.w.length;\n    return c;\n  };\n  self.getcharRandom = function () {\n    return self.w.charAt(Math.floor(Math.random() * self.w.length));\n  };\n  self.getWord = function () {\n    var word = words[wordIndex];\n    wordIndex = (wordIndex + 1) % words.length;\n    return word;\n  };\n  self.getText = function () {\n    return self.w;\n  };\n  self.setText = function (text) {\n    self.w = text;\n    words = self.w.split(new RegExp(SPLIT_TOKENS, 'g'));\n    wordIndex = 0;\n    charIndex = 0;\n  };\n\n  self.setText(text || defaultText);\n};\n\nexports.default = TextManager;\n\n/***/ }),\n\n/***/ 24:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Sketch;\n\nvar _undo = __webpack_require__(45);\n\nvar _undo2 = _interopRequireDefault(_undo);\n\nvar _https = __webpack_require__(27);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n A text-painter, with var coming (primarily) from 4 possible images.\n Try painting a grid, reducing the size, and painting again!\n \n UP/DOWN - change text size\n LEFT/RIGHT - change amount of \"jitter\" (random offset for painting)\n a - toggle AutoPaint (on/off)\n 1,2,3,4 - change var-source image\n stored as square \"001.jpg\" etc, in the data folder\n g - paint a grid of text covering entire screen\n m/M - change paint Mode (the default mode takes var from images)\n s - save\n x - change black/white mode. mostly applies to alternate paint modes, or clearing screen\n DELETE - clear screen; sets to white/black depending upon black/white mode (default: black) \n */\nfunction Sketch(p5, textManager) {\n\n  var textsize = 10;\n  var blackfield = '#000000';\n  var whitefield = '#FFFFFF';\n  var blackNotWhite = false;\n  var img;\n\n  var bodycopy = ['These are the pearls that were his eyes'];\n\n  var textInputBox = document.getElementById('bodycopy');\n\n  function getBodyCopy() {\n    return textInputBox.value;\n  }\n\n  function setBodyCopy(text) {\n    textInputBox.value = text;\n  }\n\n  p5.setup = function () {\n    var canvas = p5.createCanvas(700, 700);\n    canvas.parent('sketch-holder');\n    canvas.drop(gotFile);\n    setBodyCopy(p5.random(bodycopy));\n    textManager.setText(getBodyCopy());\n    var textButton = document.getElementById('applytext');\n    textButton.addEventListener('click', function () {\n      textManager.setText(getBodyCopy());\n    });\n    clearScreen();\n    p5.textSize(textsize);\n    p5.textAlign(p5.CENTER, p5.CENTER);\n    p5.frameRate(60); // change if paint events seem to be too rapid\n    curPaintMode = 2; // paint with background var.\n    setImage(4);\n  };\n\n  p5.draw = function () {\n    if (autoPaintMode) {\n      autoPaintRegion(0, 0, p5.width, p5.height);\n      return;\n    }\n\n    if (p5.mouseIsPressed && p5.mouseY > 0 && p5.mouseY < p5.height && p5.mouseX > 0 && p5.mouseX < p5.width) {\n      paintWordAtPoint(p5.mouseX, p5.mouseY);\n    }\n  };\n\n  var mouseInCanvas = function mouseInCanvas() {\n    return p5.mouseY > 0 && p5.mouseY < p5.height && p5.mouseX > 0 && p5.mouseX < p5.width;\n  };\n\n  function paintWordAtPoint(locX, locY) {\n    if (randomSizeMode) {\n      spatterWordAtPoint(locX, locY);\n    } else {\n      paintStaticSizedWordAtPoint(locX, locY);\n    }\n  }\n\n  function paintStaticSizedWordAtPoint(locX, locY) {\n\n    // absolute positioning\n    var offX = getJitter(),\n        offY = getJitter();\n    setFill(locX + offX, locY + offY);\n    p5.text(textManager.getWord(), locX + offX, locY + offY);\n  }\n\n  // paint words AROUND the point in different sizes\n  function spatterWordAtPoint(locX, locY) {\n\n    var origTextSize = textsize;\n\n    p5.textSize(randomTextSize(origTextSize));\n\n    paintStaticSizedWordAtPoint(locX, locY);\n\n    p5.textSize(origTextSize); // restore original size\n  }\n\n  function randomTextSize(prevSize) {\n    var offset = getJitter();\n    var newsize = offset + prevSize;\n    if (newsize < 2) newsize = 2;\n    return newsize;\n  }\n\n  function clearScreen() {\n    var field = blackNotWhite ? whitefield : blackfield;\n    p5.background(field);\n  }\n\n  function changeTextsize(direction) {\n    var step = 5;\n    textsize = textsize + step * direction;\n    if (textsize < 1) textsize = step;\n    p5.textSize(textsize);\n  }\n\n  var jitRange = 20;\n  function getJitter() {\n    return getRandomInt(-jitRange, jitRange);\n  }\n\n  function setJitRange(direction) {\n    var step = 5;\n    jitRange = jitRange + step * direction;\n    if (jitRange < 1) jitRange = 1;\n  }\n\n  var imageReady = function imageReady() {\n    img.resize(0, p5.height);\n    img.loadPixels();\n  };\n\n  // select one of the 4 images\n  // this BEGS for a refactoring\n  /* @pjs preload=\"001.jpg,002.jpg,003.jpg,004.jpg\"; */\n  function setImage(image) {\n    switch (image) {\n      case 1:\n        img = p5.loadImage(\"./assets/001.jpg\", imageReady);\n        break;\n\n      case 2:\n        img = p5.loadImage(\"./assets/002.jpg\", imageReady);\n        break;\n\n      case 3:\n        img = p5.loadImage(\"./assets/003.jpg\", imageReady);\n        break;\n\n      case 4:\n        img = p5.loadImage(\"./assets/004.jpg\", imageReady);\n        break;\n    }\n  }\n\n  // print a grid of characters from upper-left to lower-right\n  function paintGrid() {\n    p5.textAlign(p5.LEFT, p5.BOTTOM);\n    var nextX = 0,\n        nextY = 0,\n        yOffset = p5.textAscent() + p5.textDescent();\n    var w = textManager.getchar();\n    nextY = nextY + yOffset;\n    while (nextX < p5.width && nextY - yOffset < p5.height) {\n      setFill(nextX, nextY);\n      p5.text(w, nextX, nextY);\n      nextX = nextX + p5.textWidth(w);\n      w = textManager.getchar();\n      if (nextX + p5.textWidth(w) > p5.width) {\n        nextX = 0;\n        nextY = nextY + yOffset;\n      }\n    }\n    p5.textAlign(p5.CENTER, p5.CENTER);\n  }\n\n  var paintModes = 3;\n  var curPaintMode = 0;\n  function nextPaintMode(direction) {\n    curPaintMode = (curPaintMode + direction) % paintModes;\n    if (curPaintMode < 0) curPaintMode = paintModes - 1;\n  }\n\n  function setFill(locX, locY) {\n\n    if (locX < 0) locX = 0;\n    if (locX >= p5.width) locX = p5.width - 1;\n    if (locY < 0) locY = 0;\n    if (locY >= p5.height) locY = p5.height - 1;\n\n    switch (curPaintMode) {\n\n      case 0:\n      default:\n        if (blackNotWhite) {\n          p5.fill(0, p5.height, 0);\n        } else {\n          p5.fill(0, 0, 100);\n        }\n\n        break;\n\n      // this is the one I'm really interested in for the project\n      case 2:\n        var sx = locX;\n        var sy = locY;\n        // This is adapted from the get() source - but is faster, since loadPixels()\n        // is not performed on each iteration\n        var pix = img.drawingContext.getImageData(sx, sy, 1, 1).data;\n        p5.fill(pix[0], pix[1], pix[2], pix[3]);\n        break;\n\n      case 1:\n        // TODO: fill based on... mouseX/MouseY + offset?\n        p5.fill(locX, locY, 100);\n        break;\n    }\n  }\n\n  var autoPaintMode = false;\n  function toggleAutoPaintMode() {\n    autoPaintMode = !autoPaintMode;\n  }\n\n  var getRandomInt = function getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  function autoPaintRegion(minX, minY, maxX, maxY) {\n    var locX = getRandomInt(minX, maxX);\n    var locY = getRandomInt(minY, maxY);\n    paintWordAtPoint(locX, locY);\n  }\n\n  var randomSizeMode = true;\n  function toggleRandomSizeMode() {\n    randomSizeMode = !randomSizeMode;\n  }\n\n  function save() {\n    var filename = \"image.text.\" + frameCount + \".png\";\n    p5.saveFrame(filename);\n    console.log(\"saved as: \" + filename);\n    return filename;\n  }\n\n  p5.keyPressed = function () {\n    if (!mouseInCanvas()) return;\n    var handled = keyPresser(p5.keyCode);\n    return !handled;\n  };\n\n  p5.keyTyped = function () {\n    if (!mouseInCanvas()) return;\n    keyHandler(p5.key);\n    return false;\n  };\n\n  var keyPresser = function keyPresser(keyCode) {\n    if (keyCode == p5.UP_ARROW || keyCode == p5.DOWN_ARROW) {\n      if (keyCode == p5.UP_ARROW) {\n        changeTextsize(1);\n      } else {\n        changeTextsize(-1);\n      }\n    } else if (keyCode == p5.RIGHT_ARROW || keyCode == p5.LEFT_ARROW) {\n      if (keyCode == p5.RIGHT_ARROW) {\n        setJitRange(1);\n      } else {\n        setJitRange(-1);\n      }\n    } else if (keyCode == p5.BACKSPACE || keyCode == p5.DELETE) {\n      clearScreen();\n    }\n  };\n\n  function keyHandler(char) {\n    switch (char) {\n\n      case '1':\n        setImage(1);\n        break;\n\n      case '2':\n        setImage(2);\n        break;\n\n      case '3':\n        setImage(3);\n        break;\n\n      case '4':\n        setImage(4);\n        break;\n\n      case 'a':\n        toggleAutoPaintMode();\n        break;\n\n      case 'c':\n        clearScreen();\n        break;\n\n      case 'g':\n        paintGrid();\n        break;\n\n      case 'm':\n        nextPaintMode(1);\n        break;\n      case 'M':\n        nextPaintMode(-1);\n        break;\n\n      case 'r':\n        toggleRandomSizeMode();\n        break;\n\n      case 's':\n        save();\n        break;\n\n      case 'x':\n      case 'X':\n        blackNotWhite = !blackNotWhite;\n        setFill(p5.mouseX, p5.mouseY);\n        break;\n\n      // not working in processing.js\n      case p5.DELETE:\n      case p5.BACKSPACE:\n        clearScreen();\n        break;\n    }\n  }\n\n  function gotFile(file) {\n    // If it's an image file\n    if (file.type === 'image') {\n      // Create an image DOM element but don't show it\n      img = p5.loadImage(file.data, imageReady);\n      // Draw the image onto the canvas\n      // p5.image(img, 0, 0, p5.width, p5.height);\n      // img = p5.loadImage(\"./assets/001.jpg\", imageReady)\n    } else {\n      p5.println('Not an image file!');\n    }\n  }\n}\n\n/***/ }),\n\n/***/ 44:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _p = __webpack_require__(8);\n\nvar _p2 = _interopRequireDefault(_p);\n\n__webpack_require__(22);\n\nvar _TextManager = __webpack_require__(23);\n\nvar _TextManager2 = _interopRequireDefault(_TextManager);\n\nvar _sketch = __webpack_require__(24);\n\nvar _sketch2 = _interopRequireDefault(_sketch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconsole.log('APP-VERSION: ' + \"0.1.1\");\n\nvar t = new _TextManager2.default();\n\nfunction builder(p) {\n  myP5 = new _sketch2.default(p, t);\n}\n\nvar myP5 = new _p2.default(builder);\n\n/***/ }),\n\n/***/ 45:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// based on processing.js code at https://www.openprocessing.org/sketch/131411\n\nvar Undo = function Undo(p5, levels) {\n  _classCallCheck(this, Undo);\n\n  // Number of currently available undo and redo snapshots\n  var undoSteps = 0;\n  var redoSteps = 0;\n  var images = new CircImgCollection(p5, levels);\n\n  this.takeSnapshot = function () {\n    undoSteps = Math.min(undoSteps + 1, images.amount - 1);\n    // each time we draw we disable redo\n    redoSteps = 0;\n    images.next();\n    images.capture();\n  };\n\n  this.undo = function () {\n    if (undoSteps > 0) {\n      undoSteps--;\n      redoSteps++;\n      images.prev();\n      images.show();\n    }\n  };\n  this.redo = function () {\n    if (redoSteps > 0) {\n      undoSteps++;\n      redoSteps--;\n      images.next();\n      images.show();\n    }\n  };\n};\n\nexports.default = Undo;\n\nvar CircImgCollection = function CircImgCollection(p5, amountOfImages) {\n  _classCallCheck(this, CircImgCollection);\n\n  var current = 0;\n  var img = [];\n\n  var amount = amountOfImages;\n  this.amount = amount;\n\n  // Initialize all images as copies of the current display\n  for (var i = 0; i < amount; i++) {\n    img[i] = p5.createImage(p5.width, p5.height);\n    img[i] = p5.get();\n  }\n\n  this.next = function () {\n    current = (current + 1) % amount;\n  };\n  this.prev = function () {\n    current = (current - 1 + amount) % amount;\n  };\n  this.capture = function () {\n    img[current] = p5.get();\n  };\n  this.show = function () {\n    p5.image(img[current], 0, 0);\n  };\n};\n\n/***/ }),\n\n/***/ 46:\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ 47:\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ })\n\n},[44]);\n\n\n// WEBPACK FOOTER //\n// bundle.fc8713a26ddc455495c5.js","export default class TextManager {\n  constructor (text) {\n    var defaultText = 'These are the pearls that were his eyes'\n    var SPLIT_TOKENS = '[ ?.,;:<>()\"]'\n    var words = []\n    var charIndex = 0\n    var wordIndex = 0\n    let self = this\n    self.getchar = function () {\n      var c = self.w.charAt(charIndex)\n      charIndex = (charIndex + 1) % self.w.length\n      return c\n    }\n    self.getcharRandom = function () {\n      return self.w.charAt(Math.floor(Math.random() * self.w.length))\n    }\n    self.getWord = function () {\n      var word = words[wordIndex]\n      wordIndex = (wordIndex + 1) % words.length\n      return word\n    }\n    self.getText = function () {\n      return self.w\n    }\n    self.setText = function (text) {\n      self.w = text\n      words = self.w.split(new RegExp(SPLIT_TOKENS, 'g'))\n      wordIndex = 0\n      charIndex = 0\n    }\n\n    self.setText(text || defaultText)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/sketch/TextManager.js","/*\n A text-painter, with var coming (primarily) from 4 possible images.\n Try painting a grid, reducing the size, and painting again!\n \n UP/DOWN - change text size\n LEFT/RIGHT - change amount of \"jitter\" (random offset for painting)\n a - toggle AutoPaint (on/off)\n 1,2,3,4 - change var-source image\n stored as square \"001.jpg\" etc, in the data folder\n g - paint a grid of text covering entire screen\n m/M - change paint Mode (the default mode takes var from images)\n s - save\n x - change black/white mode. mostly applies to alternate paint modes, or clearing screen\n DELETE - clear screen; sets to white/black depending upon black/white mode (default: black) \n */\nimport Undo from './undo.js'\nimport { get } from 'https';\n\nexport default function Sketch(p5, textManager) {\n\n  var textsize = 10;\n  var blackfield = '#000000';\n  var whitefield = '#FFFFFF';\n  var blackNotWhite = false;\n  var img;\n\n  var bodycopy = ['These are the pearls that were his eyes']\n\n  const textInputBox = document.getElementById('bodycopy')\n\n  function getBodyCopy () {\n    return textInputBox.value\n  }\n  \n  function setBodyCopy (text) {\n    textInputBox.value = text\n  }\n\n  p5.setup = () => {\n    const canvas = p5.createCanvas(700, 700)\n    canvas.parent('sketch-holder')\n    canvas.drop(gotFile);\n    setBodyCopy(p5.random(bodycopy))\n    textManager.setText(getBodyCopy())\n    const textButton = document.getElementById('applytext')\n    textButton.addEventListener('click', () => {\n      textManager.setText(getBodyCopy())\n    })\n    clearScreen();\n    p5.textSize(textsize);\n    p5.textAlign(p5.CENTER, p5.CENTER);\n    p5.frameRate(60); // change if paint events seem to be too rapid\n    curPaintMode = 2; // paint with background var.\n    setImage(4);\n  }\n\n  p5.draw = () => {\n    if (autoPaintMode) {\n      autoPaintRegion(0, 0, p5.width, p5.height);\n      return;\n    }\n\n    if (p5.mouseIsPressed && p5.mouseY > 0 && p5.mouseY < p5.height\n      && p5.mouseX > 0 && p5.mouseX < p5.width) {\n      paintWordAtPoint(p5.mouseX, p5.mouseY);\n    }\n  }\n\n  const mouseInCanvas = () => {\n    return p5.mouseY > 0 && p5.mouseY < p5.height && p5.mouseX > 0 && p5.mouseX < p5.width\n  }\n\n  function paintWordAtPoint(locX, locY) {\n    if (randomSizeMode) {\n      spatterWordAtPoint(locX, locY);\n    }\n    else {\n      paintStaticSizedWordAtPoint(locX, locY);\n    }\n  }\n\n  function paintStaticSizedWordAtPoint(locX, locY) {\n\n    // absolute positioning\n    var offX = getJitter(), offY = getJitter();\n    setFill(locX + offX, locY + offY);\n    p5.text(textManager.getWord(), locX + offX, locY + offY);\n  }\n\n  // paint words AROUND the point in different sizes\n  function spatterWordAtPoint(locX, locY) {\n\n    var origTextSize = textsize;\n\n    p5.textSize(randomTextSize(origTextSize));\n\n    paintStaticSizedWordAtPoint(locX, locY);\n\n    p5.textSize(origTextSize); // restore original size\n  }\n\n\n  function randomTextSize(prevSize) {\n    var offset = getJitter();\n    var newsize = offset + prevSize;\n    if (newsize < 2) newsize = 2;\n    return newsize;\n  }\n\n\n  function clearScreen() {\n    var field = blackNotWhite ? whitefield : blackfield;\n    p5.background(field);\n  }\n\n  function changeTextsize(direction) {\n    var step = 5;\n    textsize = (textsize + step * direction);\n    if (textsize < 1) textsize = step;\n    p5.textSize(textsize);\n  }\n\n\n  var jitRange = 20;\n  function getJitter() {\n    return getRandomInt(-jitRange, jitRange)\n  }\n\n  function setJitRange(direction) {\n    var step = 5;\n    jitRange = (jitRange + step * direction);\n    if (jitRange < 1) jitRange = 1;\n  }\n\n\n  const imageReady = () => {\n    img.resize(0, p5.height);\n    img.loadPixels()\n  }\n\n  // select one of the 4 images\n  // this BEGS for a refactoring\n  /* @pjs preload=\"001.jpg,002.jpg,003.jpg,004.jpg\"; */\n  function setImage(image) {\n    switch (image) {\n      case 1:\n        img = p5.loadImage(\"./assets/001.jpg\", imageReady)\n        break;\n\n      case 2:\n        img = p5.loadImage(\"./assets/002.jpg\", imageReady)\n        break;\n\n      case 3:\n        img = p5.loadImage(\"./assets/003.jpg\", imageReady)\n        break;\n\n      case 4:\n        img = p5.loadImage(\"./assets/004.jpg\", imageReady)\n        break;\n    }\n  }\n\n  // print a grid of characters from upper-left to lower-right\n  function paintGrid() {\n    p5.textAlign(p5.LEFT, p5.BOTTOM);\n    var nextX = 0, nextY = 0, yOffset = (p5.textAscent() + p5.textDescent());\n    var w = textManager.getchar();\n    nextY = nextY + yOffset;\n    while (nextX < p5.width && (nextY - yOffset) < p5.height) {\n      setFill(nextX, nextY);\n      p5.text(w, nextX, nextY);\n      nextX = nextX + p5.textWidth(w);\n      w = textManager.getchar();\n      if (nextX + p5.textWidth(w) > p5.width) {\n        nextX = 0;\n        nextY = nextY + yOffset;\n      }\n    }\n    p5.textAlign(p5.CENTER, p5.CENTER);\n  }\n\n\n  var paintModes = 3;\n  var curPaintMode = 0;\n  function nextPaintMode(direction) {\n    curPaintMode = (curPaintMode + direction) % paintModes;\n    if (curPaintMode < 0) curPaintMode = paintModes - 1;\n  }\n\n  function setFill(locX, locY) {\n\n    if (locX < 0) locX = 0;\n    if (locX >= p5.width) locX = p5.width - 1;\n    if (locY < 0) locY = 0;\n    if (locY >= p5.height) locY = p5.height - 1;\n\n    switch (curPaintMode) {\n\n      case 0:\n      default:\n        if (blackNotWhite) {\n          p5.fill(0, p5.height, 0);\n        }\n        else {\n          p5.fill(0, 0, 100);\n        }\n\n        break;\n\n      // this is the one I'm really interested in for the project\n      case 2:\n        var sx = locX\n        var sy = locY\n        // This is adapted from the get() source - but is faster, since loadPixels()\n        // is not performed on each iteration\n        var pix = img.drawingContext.getImageData(sx, sy, 1, 1).data;\n        p5.fill(pix[0], pix[1], pix[2], pix[3]);\n        break;\n\n      case 1:\n        // TODO: fill based on... mouseX/MouseY + offset?\n        p5.fill(locX, locY, 100);\n        break;\n    }\n  }\n\n  var autoPaintMode = false;\n  function toggleAutoPaintMode() {\n    autoPaintMode = !autoPaintMode;\n  }\n\n  const getRandomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function autoPaintRegion(minX, minY, maxX, maxY) {\n    var locX = getRandomInt(minX, maxX)\n    let locY = getRandomInt(minY, maxY)\n    paintWordAtPoint(locX, locY)\n  }\n\n\n  let randomSizeMode = true;\n  function toggleRandomSizeMode() {\n    randomSizeMode = !randomSizeMode;\n  }\n\n  function save() {\n    var filename = \"image.text.\" + frameCount + \".png\";\n    p5.saveFrame(filename);\n    console.log(\"saved as: \" + filename);\n    return filename;\n  }\n\n  p5.keyPressed = () => {\n    if (!mouseInCanvas()) return\n    let handled = keyPresser(p5.keyCode)\n    return !handled\n  }\n\n  p5.keyTyped = () => {\n    if (!mouseInCanvas()) return\n    keyHandler(p5.key)\n    return false\n  }\n\n  const keyPresser = (keyCode) => {\n    if (keyCode == p5.UP_ARROW || keyCode == p5.DOWN_ARROW) {\n      if (keyCode == p5.UP_ARROW) {\n        changeTextsize(1);\n      }\n      else {\n        changeTextsize(-1);\n      }\n    }\n    else if (keyCode == p5.RIGHT_ARROW || keyCode == p5.LEFT_ARROW) {\n      if (keyCode == p5.RIGHT_ARROW) {\n        setJitRange(1);\n      }\n      else {\n        setJitRange(-1);\n      }\n    }\n    else if (keyCode == p5.BACKSPACE || keyCode == p5.DELETE) {\n      clearScreen();\n    }\n  }\n\n  function keyHandler(char) {\n    switch (char) {\n\n      case '1':\n        setImage(1);\n        break;\n\n      case '2':\n        setImage(2);\n        break;\n\n      case '3':\n        setImage(3);\n        break;\n\n      case '4':\n        setImage(4);\n        break;\n\n      case 'a':\n        toggleAutoPaintMode();\n        break;\n\n      case 'c':\n        clearScreen();\n        break;\n\n      case 'g':\n        paintGrid();\n        break;\n\n      case 'm':\n        nextPaintMode(1);\n        break;\n      case 'M':\n        nextPaintMode(-1);\n        break;\n\n      case 'r':\n        toggleRandomSizeMode();\n        break;\n\n      case 's':\n        save();\n        break;\n\n      case 'x':\n      case 'X':\n        blackNotWhite = !blackNotWhite;\n        setFill(p5.mouseX, p5.mouseY);\n        break;\n\n      // not working in processing.js\n      case p5.DELETE:\n      case p5.BACKSPACE:\n        clearScreen();\n        break;\n    }\n  }\n\n  function gotFile(file) {\n    // If it's an image file\n    if (file.type === 'image') {\n      // Create an image DOM element but don't show it\n      img = p5.loadImage(file.data, imageReady)\n      // Draw the image onto the canvas\n      // p5.image(img, 0, 0, p5.width, p5.height);\n      // img = p5.loadImage(\"./assets/001.jpg\", imageReady)\n\n    } else {\n      p5.println('Not an image file!');\n    }\n  }\n\n}\n\n\n// WEBPACK FOOTER //\n// ./src/sketch/sketch.js","import P5 from 'p5'\nimport 'p5/lib/addons/p5.dom'\n\nimport TextManager from './sketch/TextManager'\nimport Sketch from './sketch/sketch.js'\n\nconsole.log(`APP-VERSION: ${VERSION}`)\n\nlet t = new TextManager()\n\nfunction builder (p) {\n  myP5 = new Sketch(p, t)\n}\n\nvar myP5 = new P5(builder)\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// based on processing.js code at https://www.openprocessing.org/sketch/131411\n\nexport default class Undo {\n  constructor (p5, levels) {\n    // Number of currently available undo and redo snapshots\n    let undoSteps = 0\n    let redoSteps = 0\n    let images = new CircImgCollection(p5, levels)\n\n    this.takeSnapshot = () => {\n      undoSteps = Math.min(undoSteps + 1, images.amount - 1)\n      // each time we draw we disable redo\n      redoSteps = 0\n      images.next()\n      images.capture()\n    }\n\n    this.undo = () => {\n      if (undoSteps > 0) {\n        undoSteps--\n        redoSteps++\n        images.prev()\n        images.show()\n      }\n    }\n    this.redo = () => {\n      if (redoSteps > 0) {\n        undoSteps++\n        redoSteps--\n        images.next()\n        images.show()\n      }\n    }\n  }\n}\n\nclass CircImgCollection {\n  constructor (p5, amountOfImages) {\n    let current = 0\n    let img = []\n\n    let amount = amountOfImages\n    this.amount = amount\n\n    // Initialize all images as copies of the current display\n    for (let i = 0; i < amount; i++) {\n      img[i] = p5.createImage(p5.width, p5.height)\n      img[i] = p5.get()\n    }\n\n    this.next = () => {\n      current = (current + 1) % amount\n    }\n    this.prev = () => {\n      current = (current - 1 + amount) % amount\n    }\n    this.capture = () => {\n      img[current] = p5.get()\n    }\n    this.show = () => {\n      p5.image(img[current], 0, 0)\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/sketch/undo.js"],"sourceRoot":""}