{"version":3,"sources":["webpack:///bundle.2f16249d3dcbd5994842.js","webpack:///./src/sketch/TextManager.js","webpack:///./src/sketch/sketch.js","webpack:///./src/index.js","webpack:///./src/sketch/undo.js"],"names":["webpackJsonp","22","module","exports","__webpack_require__","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","TextManager","text","this","words","charIndex","wordIndex","self","getchar","c","w","charAt","length","getcharRandom","Math","floor","random","getWord","word","getText","setText","split","RegExp","default","23","Sketch","p5","t","paintWordAtPoint","locX","locY","randomSizeMode","spatterWordAtPoint","paintStaticSizedWordAtPoint","offX","getJitter","offY","setFill","origTextSize","textsize","textSize","randomTextSize","prevSize","offset","newsize","clearScreen","field","blackNotWhite","whitefield","blackfield","background","changeTextsize","direction","getRandomInt","jitRange","setJitRange","setImage","image","img","loadImage","imageReady","paintGrid","textAlign","LEFT","BOTTOM","nextX","nextY","yOffset","textAscent","textDescent","width","height","textWidth","CENTER","nextPaintMode","curPaintMode","paintModes","fill","sx","sy","pix","drawingContext","getImageData","data","toggleAutoPaintMode","autoPaintMode","autoPaintRegion","minX","minY","maxX","maxY","toggleRandomSizeMode","save","filename","frameCount","saveFrame","console","log","keyHandler","char","mouseX","mouseY","DELETE","BACKSPACE","setup","createCanvas","parent","frameRate","draw","mouseIsPressed","mouseInCanvas","resize","loadPixels","min","max","keyPressed","keyPresser","keyCode","keyTyped","key","UP_ARROW","DOWN_ARROW","RIGHT_ARROW","LEFT_ARROW","_undo","obj","__esModule","43","_interopRequireDefault","builder","p","myP5","_p","_p2","_TextManager","_TextManager2","_sketch","_sketch2","P5","44","Undo","levels","undoSteps","redoSteps","images","CircImgCollection","takeSnapshot","amount","next","capture","undo","prev","show","redo","amountOfImages","current","i","createImage","get","45","46"],"mappings":"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","file":"bundle.2f16249d3dcbd5994842.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 22:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TextManager = function TextManager(text) {\n  _classCallCheck(this, TextManager);\n\n  var defaultText = 'These are the pearls that were his eyes';\n  // var randomText = defaultText + '...........---___*****xxx                                            '\n  var SPLIT_TOKENS = '[ ?.,;:<>()\"]';\n  var words = [];\n  var charIndex = 0;\n  var wordIndex = 0;\n  var self = this;\n  self.getchar = function () {\n    var c = self.w.charAt(charIndex);\n    charIndex = (charIndex + 1) % self.w.length;\n    return c;\n  };\n  self.getcharRandom = function () {\n    return self.w.charAt(Math.floor(Math.random() * self.w.length));\n  };\n  self.getWord = function () {\n    var word = words[wordIndex];\n    wordIndex = (wordIndex + 1) % words.length;\n    return word;\n  };\n  self.getText = function () {\n    return self.w;\n  };\n  self.setText = function (text) {\n    self.w = text;\n    words = self.w.split(new RegExp(SPLIT_TOKENS, 'g'));\n    wordIndex = 0;\n    charIndex = 0;\n  };\n\n  self.setText(text || defaultText);\n};\n\nexports.default = TextManager;\n\n/***/ }),\n\n/***/ 23:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Sketch;\n\nvar _undo = __webpack_require__(44);\n\nvar _undo2 = _interopRequireDefault(_undo);\n\nvar _https = __webpack_require__(26);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n A text-painter, with var coming (primarily) from 4 possible images.\n Try painting a grid, reducing the size, and painting again!\n \n UP/DOWN - change text size\n LEFT/RIGHT - change amount of \"jitter\" (random offset for painting)\n a - toggle AutoPaint (on/off)\n 1,2,3,4 - change var-source image\n stored as square \"001.jpg\" etc, in the data folder\n g - paint a grid of text covering entire screen\n m/M - change paint Mode (the default mode takes var from images)\n s - save\n x - change black/white mode. mostly applies to alternate paint modes, or clearing screen\n DELETE - clear screen; sets to white/black depending upon black/white mode (default: black) \n */\nfunction Sketch(p5, t) {\n\n  var textsize = 10;\n  var blackfield = '#000000';\n  var whitefield = '#FFFFFF';\n  var blackNotWhite = false;\n  var img;\n\n  p5.setup = function () {\n    var canvas = p5.createCanvas(700, 700);\n    canvas.parent('sketch-holder');\n    // p5.colorMode(p5.RGB, p5.width, p5.height, 100);\n    clearScreen();\n    p5.textSize(textsize);\n    p5.textAlign(p5.CENTER, p5.CENTER);\n    p5.frameRate(60); // change if paint events seem to be too rapid\n    curPaintMode = 2; // paint with background var.\n    setImage(4);\n  };\n\n  p5.draw = function () {\n    if (autoPaintMode) {\n      autoPaintRegion(0, 0, p5.width, p5.height);\n      return;\n    }\n\n    if (p5.mouseIsPressed && p5.mouseY > 0 && p5.mouseY < p5.height && p5.mouseX > 0 && p5.mouseX < p5.width) {\n      paintWordAtPoint(p5.mouseX, p5.mouseY);\n    }\n  };\n\n  var mouseInCanvas = function mouseInCanvas() {\n    return p5.mouseY > 0 && p5.mouseY < p5.height && p5.mouseX > 0 && p5.mouseX < p5.width;\n  };\n\n  function paintWordAtPoint(locX, locY) {\n    if (randomSizeMode) {\n      spatterWordAtPoint(locX, locY);\n    } else {\n      paintStaticSizedWordAtPoint(locX, locY);\n    }\n  }\n\n  function paintStaticSizedWordAtPoint(locX, locY) {\n\n    // absolute positioning\n    var offX = getJitter(),\n        offY = getJitter();\n    setFill(locX + offX, locY + offY);\n    p5.text(t.getWord(), locX + offX, locY + offY);\n  }\n\n  // paint words AROUND the point in different sizes\n  function spatterWordAtPoint(locX, locY) {\n\n    var origTextSize = textsize;\n\n    p5.textSize(randomTextSize(origTextSize));\n\n    paintStaticSizedWordAtPoint(locX, locY);\n\n    p5.textSize(origTextSize); // restore original size\n  }\n\n  function randomTextSize(prevSize) {\n    var offset = getJitter();\n    var newsize = offset + prevSize;\n    if (newsize < 2) newsize = 2;\n    return newsize;\n  }\n\n  function clearScreen() {\n    var field = blackNotWhite ? whitefield : blackfield;\n    p5.background(field);\n  }\n\n  function changeTextsize(direction) {\n    var step = 5;\n    textsize = textsize + step * direction;\n    if (textsize < 1) textsize = step;\n    p5.textSize(textsize);\n  }\n\n  var jitRange = 20;\n  function getJitter() {\n    return getRandomInt(-jitRange, jitRange);\n  }\n\n  function setJitRange(direction) {\n    var step = 5;\n    jitRange = jitRange + step * direction;\n    if (jitRange < 1) jitRange = 1;\n  }\n\n  var imageReady = function imageReady() {\n    img.resize(0, p5.height);\n    img.loadPixels();\n  };\n\n  // select one of the 4 images\n  // this BEGS for a refactoring\n  /* @pjs preload=\"001.jpg,002.jpg,003.jpg,004.jpg\"; */\n  function setImage(image) {\n    switch (image) {\n      case 1:\n        img = p5.loadImage(\"./assets/001.jpg\", imageReady);\n        break;\n\n      case 2:\n        img = p5.loadImage(\"./assets/002.jpg\", imageReady);\n        break;\n\n      case 3:\n        img = p5.loadImage(\"./assets/003.jpg\", imageReady);\n        break;\n\n      case 4:\n        img = p5.loadImage(\"./assets/004.jpg\", imageReady);\n        break;\n    }\n  }\n\n  // print a grid of characters from upper-left to lower-right\n  function paintGrid() {\n    p5.textAlign(p5.LEFT, p5.BOTTOM);\n    var nextX = 0,\n        nextY = 0,\n        yOffset = p5.textAscent() + p5.textDescent();\n    var w = t.getchar();\n    nextY = nextY + yOffset;\n    while (nextX < p5.width && nextY - yOffset < p5.height) {\n      setFill(nextX, nextY);\n      p5.text(w, nextX, nextY);\n      nextX = nextX + p5.textWidth(w);\n      w = t.getchar();\n      if (nextX + p5.textWidth(w) > p5.width) {\n        nextX = 0;\n        nextY = nextY + yOffset;\n      }\n    }\n    p5.textAlign(p5.CENTER, p5.CENTER);\n  }\n\n  var paintModes = 3;\n  var curPaintMode = 0;\n  function nextPaintMode(direction) {\n    curPaintMode = (curPaintMode + direction) % paintModes;\n    if (curPaintMode < 0) curPaintMode = paintModes - 1;\n  }\n\n  function setFill(locX, locY) {\n\n    if (locX < 0) locX = 0;\n    if (locX >= p5.width) locX = p5.width - 1;\n    if (locY < 0) locY = 0;\n    if (locY >= p5.height) locY = p5.height - 1;\n\n    switch (curPaintMode) {\n\n      case 0:\n      default:\n        if (blackNotWhite) {\n          p5.fill(0, p5.height, 0);\n        } else {\n          p5.fill(0, 0, 100);\n        }\n\n        break;\n\n      // this is the one I'm really interested in for the project\n      case 2:\n        var sx = locX;\n        var sy = locY;\n        // This is adapted from the get() source - but is faster, since loadPixels()\n        // is not performed on each iteration\n        var pix = img.drawingContext.getImageData(sx, sy, 1, 1).data;\n        p5.fill(pix[0], pix[1], pix[2], pix[3]);\n        break;\n\n      case 1:\n        // TODO: fill based on... mouseX/MouseY + offset?\n        p5.fill(locX, locY, 100);\n        break;\n    }\n  }\n\n  var autoPaintMode = false;\n  function toggleAutoPaintMode() {\n    autoPaintMode = !autoPaintMode;\n  }\n\n  var getRandomInt = function getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  };\n\n  function autoPaintRegion(minX, minY, maxX, maxY) {\n    var locX = getRandomInt(minX, maxX);\n    var locY = getRandomInt(minY, maxY);\n    paintWordAtPoint(locX, locY);\n  }\n\n  var randomSizeMode = true;\n  function toggleRandomSizeMode() {\n    randomSizeMode = !randomSizeMode;\n  }\n\n  function save() {\n    var filename = \"image.text.\" + frameCount + \".png\";\n    p5.saveFrame(filename);\n    console.log(\"saved as: \" + filename);\n    return filename;\n  }\n\n  p5.keyPressed = function () {\n    if (!mouseInCanvas()) return;\n    var handled = keyPresser(p5.keyCode);\n    return !handled;\n  };\n\n  p5.keyTyped = function () {\n    if (!mouseInCanvas()) return;\n    keyHandler(p5.key);\n    return false;\n  };\n\n  var keyPresser = function keyPresser(keyCode) {\n    if (keyCode == p5.UP_ARROW || keyCode == p5.DOWN_ARROW) {\n      if (keyCode == p5.UP_ARROW) {\n        changeTextsize(1);\n      } else {\n        changeTextsize(-1);\n      }\n    } else if (keyCode == p5.RIGHT_ARROW || keyCode == p5.LEFT_ARROW) {\n      if (keyCode == p5.RIGHT_ARROW) {\n        setJitRange(1);\n      } else {\n        setJitRange(-1);\n      }\n    } else if (keyCode == p5.BACKSPACE || keyCode == p5.DELETE) {\n      clearScreen();\n    }\n  };\n\n  function keyHandler(char) {\n    switch (char) {\n\n      case '1':\n        setImage(1);\n        break;\n\n      case '2':\n        setImage(2);\n        break;\n\n      case '3':\n        setImage(3);\n        break;\n\n      case '4':\n        setImage(4);\n        break;\n\n      case 'a':\n        toggleAutoPaintMode();\n        break;\n\n      case 'c':\n        clearScreen();\n        break;\n\n      case 'g':\n        paintGrid();\n        break;\n\n      case 'm':\n        nextPaintMode(1);\n        break;\n      case 'M':\n        nextPaintMode(-1);\n        break;\n\n      case 'r':\n        toggleRandomSizeMode();\n        break;\n\n      case 's':\n        save();\n        break;\n\n      case 'x':\n      case 'X':\n        blackNotWhite = !blackNotWhite;\n        setFill(p5.mouseX, p5.mouseY);\n        break;\n\n      // not working in processing.js\n      case p5.DELETE:\n      case p5.BACKSPACE:\n        clearScreen();\n        break;\n    }\n  }\n}\n\n/***/ }),\n\n/***/ 43:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _p = __webpack_require__(21);\n\nvar _p2 = _interopRequireDefault(_p);\n\nvar _TextManager = __webpack_require__(22);\n\nvar _TextManager2 = _interopRequireDefault(_TextManager);\n\nvar _sketch = __webpack_require__(23);\n\nvar _sketch2 = _interopRequireDefault(_sketch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// console.log(`APP-VERSION: ${VERSION}`)\n\nvar t = new _TextManager2.default();\n\nfunction builder(p) {\n  myP5 = new _sketch2.default(p, t);\n}\n\nvar myP5 = new _p2.default(builder);\n\n/***/ }),\n\n/***/ 44:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// based on processing.js code at https://www.openprocessing.org/sketch/131411\n\nvar Undo = function Undo(p5, levels) {\n  _classCallCheck(this, Undo);\n\n  // Number of currently available undo and redo snapshots\n  var undoSteps = 0;\n  var redoSteps = 0;\n  var images = new CircImgCollection(p5, levels);\n\n  this.takeSnapshot = function () {\n    undoSteps = Math.min(undoSteps + 1, images.amount - 1);\n    // each time we draw we disable redo\n    redoSteps = 0;\n    images.next();\n    images.capture();\n  };\n\n  this.undo = function () {\n    if (undoSteps > 0) {\n      undoSteps--;\n      redoSteps++;\n      images.prev();\n      images.show();\n    }\n  };\n  this.redo = function () {\n    if (redoSteps > 0) {\n      undoSteps++;\n      redoSteps--;\n      images.next();\n      images.show();\n    }\n  };\n};\n\nexports.default = Undo;\n\nvar CircImgCollection = function CircImgCollection(p5, amountOfImages) {\n  _classCallCheck(this, CircImgCollection);\n\n  var current = 0;\n  var img = [];\n\n  var amount = amountOfImages;\n  this.amount = amount;\n\n  // Initialize all images as copies of the current display\n  for (var i = 0; i < amount; i++) {\n    img[i] = p5.createImage(p5.width, p5.height);\n    img[i] = p5.get();\n  }\n\n  this.next = function () {\n    current = (current + 1) % amount;\n  };\n  this.prev = function () {\n    current = (current - 1 + amount) % amount;\n  };\n  this.capture = function () {\n    img[current] = p5.get();\n  };\n  this.show = function () {\n    p5.image(img[current], 0, 0);\n  };\n};\n\n/***/ }),\n\n/***/ 45:\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ }),\n\n/***/ 46:\n/***/ (function(module, exports) {\n\n/* (ignored) */\n\n/***/ })\n\n},[43]);\n\n\n// WEBPACK FOOTER //\n// bundle.2f16249d3dcbd5994842.js","export default class TextManager {\n  constructor (text) {\n    var defaultText = 'These are the pearls that were his eyes'\n    // var randomText = defaultText + '...........---___*****xxx                                            '\n    var SPLIT_TOKENS = '[ ?.,;:<>()\"]'\n    var words = []\n    var charIndex = 0\n    var wordIndex = 0\n    let self = this\n    self.getchar = function () {\n      var c = self.w.charAt(charIndex)\n      charIndex = (charIndex + 1) % self.w.length\n      return c\n    }\n    self.getcharRandom = function () {\n      return self.w.charAt(Math.floor(Math.random() * self.w.length))\n    }\n    self.getWord = function () {\n      var word = words[wordIndex]\n      wordIndex = (wordIndex + 1) % words.length\n      return word\n    }\n    self.getText = function () {\n      return self.w\n    }\n    self.setText = function (text) {\n      self.w = text\n      words = self.w.split(new RegExp(SPLIT_TOKENS, 'g'))\n      wordIndex = 0\n      charIndex = 0\n    }\n\n    self.setText(text || defaultText)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/sketch/TextManager.js","/*\n A text-painter, with var coming (primarily) from 4 possible images.\n Try painting a grid, reducing the size, and painting again!\n \n UP/DOWN - change text size\n LEFT/RIGHT - change amount of \"jitter\" (random offset for painting)\n a - toggle AutoPaint (on/off)\n 1,2,3,4 - change var-source image\n stored as square \"001.jpg\" etc, in the data folder\n g - paint a grid of text covering entire screen\n m/M - change paint Mode (the default mode takes var from images)\n s - save\n x - change black/white mode. mostly applies to alternate paint modes, or clearing screen\n DELETE - clear screen; sets to white/black depending upon black/white mode (default: black) \n */\nimport Undo from './undo.js'\nimport { get } from 'https';\n\nexport default function Sketch(p5, t) {\n\n  var textsize = 10;\n  var blackfield = '#000000';\n  var whitefield = '#FFFFFF';\n  var blackNotWhite = false;\n  var img;\n\n  p5.setup = () => {\n    const canvas = p5.createCanvas(700, 700)\n    canvas.parent('sketch-holder')\n    // p5.colorMode(p5.RGB, p5.width, p5.height, 100);\n    clearScreen();\n    p5.textSize(textsize);\n    p5.textAlign(p5.CENTER, p5.CENTER);\n    p5.frameRate(60); // change if paint events seem to be too rapid\n    curPaintMode = 2; // paint with background var.\n    setImage(4);\n  }\n\n  p5.draw = () => {\n    if (autoPaintMode) {\n      autoPaintRegion(0, 0, p5.width, p5.height);\n      return;\n    }\n\n    if (p5.mouseIsPressed && p5.mouseY > 0 && p5.mouseY < p5.height\n      && p5.mouseX > 0 && p5.mouseX < p5.width) {\n      paintWordAtPoint(p5.mouseX, p5.mouseY);\n    }\n  }\n\n  const mouseInCanvas = () => {\n    return p5.mouseY > 0 && p5.mouseY < p5.height && p5.mouseX > 0 && p5.mouseX < p5.width\n  }\n\n  function paintWordAtPoint(locX, locY) {\n    if (randomSizeMode) {\n      spatterWordAtPoint(locX, locY);\n    }\n    else {\n      paintStaticSizedWordAtPoint(locX, locY);\n    }\n  }\n\n  function paintStaticSizedWordAtPoint(locX, locY) {\n\n    // absolute positioning\n    var offX = getJitter(), offY = getJitter();\n    setFill(locX + offX, locY + offY);\n    p5.text(t.getWord(), locX + offX, locY + offY);\n  }\n\n  // paint words AROUND the point in different sizes\n  function spatterWordAtPoint(locX, locY) {\n\n    var origTextSize = textsize;\n\n    p5.textSize(randomTextSize(origTextSize));\n\n    paintStaticSizedWordAtPoint(locX, locY);\n\n    p5.textSize(origTextSize); // restore original size\n  }\n\n\n  function randomTextSize(prevSize) {\n    var offset = getJitter();\n    var newsize = offset + prevSize;\n    if (newsize < 2) newsize = 2;\n    return newsize;\n  }\n\n\n  function clearScreen() {\n    var field = blackNotWhite ? whitefield : blackfield;\n    p5.background(field);\n  }\n\n  function changeTextsize(direction) {\n    var step = 5;\n    textsize = (textsize + step * direction);\n    if (textsize < 1) textsize = step;\n    p5.textSize(textsize);\n  }\n\n\n  var jitRange = 20;\n  function getJitter() {\n    return getRandomInt(-jitRange, jitRange)\n  }\n\n  function setJitRange(direction) {\n    var step = 5;\n    jitRange = (jitRange + step * direction);\n    if (jitRange < 1) jitRange = 1;\n  }\n\n\n  const imageReady = () => {\n    img.resize(0, p5.height);\n    img.loadPixels()\n  }\n\n  // select one of the 4 images\n  // this BEGS for a refactoring\n  /* @pjs preload=\"001.jpg,002.jpg,003.jpg,004.jpg\"; */\n  function setImage(image) {\n    switch (image) {\n      case 1:\n        img = p5.loadImage(\"./assets/001.jpg\", imageReady)\n        break;\n\n      case 2:\n        img = p5.loadImage(\"./assets/002.jpg\", imageReady)\n        break;\n\n      case 3:\n        img = p5.loadImage(\"./assets/003.jpg\", imageReady)\n        break;\n\n      case 4:\n        img = p5.loadImage(\"./assets/004.jpg\", imageReady)\n        break;\n    }\n  }\n\n  // print a grid of characters from upper-left to lower-right\n  function paintGrid() {\n    p5.textAlign(p5.LEFT, p5.BOTTOM);\n    var nextX = 0, nextY = 0, yOffset = (p5.textAscent() + p5.textDescent());\n    var w = t.getchar();\n    nextY = nextY + yOffset;\n    while (nextX < p5.width && (nextY - yOffset) < p5.height) {\n      setFill(nextX, nextY);\n      p5.text(w, nextX, nextY);\n      nextX = nextX + p5.textWidth(w);\n      w = t.getchar();\n      if (nextX + p5.textWidth(w) > p5.width) {\n        nextX = 0;\n        nextY = nextY + yOffset;\n      }\n    }\n    p5.textAlign(p5.CENTER, p5.CENTER);\n  }\n\n\n  var paintModes = 3;\n  var curPaintMode = 0;\n  function nextPaintMode(direction) {\n    curPaintMode = (curPaintMode + direction) % paintModes;\n    if (curPaintMode < 0) curPaintMode = paintModes - 1;\n  }\n\n  function setFill(locX, locY) {\n\n    if (locX < 0) locX = 0;\n    if (locX >= p5.width) locX = p5.width - 1;\n    if (locY < 0) locY = 0;\n    if (locY >= p5.height) locY = p5.height - 1;\n\n    switch (curPaintMode) {\n\n      case 0:\n      default:\n        if (blackNotWhite) {\n          p5.fill(0, p5.height, 0);\n        }\n        else {\n          p5.fill(0, 0, 100);\n        }\n\n        break;\n\n      // this is the one I'm really interested in for the project\n      case 2:\n        var sx = locX\n        var sy = locY\n        // This is adapted from the get() source - but is faster, since loadPixels()\n        // is not performed on each iteration\n        var pix = img.drawingContext.getImageData(sx, sy, 1, 1).data;\n        p5.fill(pix[0], pix[1], pix[2], pix[3]);\n        break;\n\n      case 1:\n        // TODO: fill based on... mouseX/MouseY + offset?\n        p5.fill(locX, locY, 100);\n        break;\n    }\n  }\n\n  var autoPaintMode = false;\n  function toggleAutoPaintMode() {\n    autoPaintMode = !autoPaintMode;\n  }\n\n  const getRandomInt = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n  }\n\n  function autoPaintRegion(minX, minY, maxX, maxY) {\n    var locX = getRandomInt(minX, maxX)\n    let locY = getRandomInt(minY, maxY)\n    paintWordAtPoint(locX, locY)\n  }\n\n\n  let randomSizeMode = true;\n  function toggleRandomSizeMode() {\n    randomSizeMode = !randomSizeMode;\n  }\n\n  function save() {\n    var filename = \"image.text.\" + frameCount + \".png\";\n    p5.saveFrame(filename);\n    console.log(\"saved as: \" + filename);\n    return filename;\n  }\n\n  p5.keyPressed = () => {\n    if (!mouseInCanvas()) return\n    let handled = keyPresser(p5.keyCode)\n    return !handled\n  }\n\n  p5.keyTyped = () => {\n    if (!mouseInCanvas()) return\n    keyHandler(p5.key)\n    return false\n  }\n\n  const keyPresser = (keyCode) => {\n    if (keyCode == p5.UP_ARROW || keyCode == p5.DOWN_ARROW) {\n      if (keyCode == p5.UP_ARROW) {\n        changeTextsize(1);\n      }\n      else {\n        changeTextsize(-1);\n      }\n    }\n    else if (keyCode == p5.RIGHT_ARROW || keyCode == p5.LEFT_ARROW) {\n      if (keyCode == p5.RIGHT_ARROW) {\n        setJitRange(1);\n      }\n      else {\n        setJitRange(-1);\n      }\n    }\n    else if (keyCode == p5.BACKSPACE || keyCode == p5.DELETE) {\n      clearScreen();\n    }\n  }\n\n  function keyHandler(char) {\n    switch (char) {\n\n      case '1':\n        setImage(1);\n        break;\n\n      case '2':\n        setImage(2);\n        break;\n\n      case '3':\n        setImage(3);\n        break;\n\n      case '4':\n        setImage(4);\n        break;\n\n      case 'a':\n        toggleAutoPaintMode();\n        break;\n\n      case 'c':\n        clearScreen();\n        break;\n\n      case 'g':\n        paintGrid();\n        break;\n\n      case 'm':\n        nextPaintMode(1);\n        break;\n      case 'M':\n        nextPaintMode(-1);\n        break;\n\n      case 'r':\n        toggleRandomSizeMode();\n        break;\n\n      case 's':\n        save();\n        break;\n\n      case 'x':\n      case 'X':\n        blackNotWhite = !blackNotWhite;\n        setFill(p5.mouseX, p5.mouseY);\n        break;\n\n      // not working in processing.js\n      case p5.DELETE:\n      case p5.BACKSPACE:\n        clearScreen();\n        break;\n    }\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/sketch/sketch.js","import P5 from 'p5'\n\nimport TextManager from './sketch/TextManager'\nimport Sketch from './sketch/sketch.js'\n\n// console.log(`APP-VERSION: ${VERSION}`)\n\nlet t = new TextManager()\n\nfunction builder (p) {\n  myP5 = new Sketch(p, t)\n}\n\nvar myP5 = new P5(builder)\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// based on processing.js code at https://www.openprocessing.org/sketch/131411\n\nexport default class Undo {\n  constructor (p5, levels) {\n    // Number of currently available undo and redo snapshots\n    let undoSteps = 0\n    let redoSteps = 0\n    let images = new CircImgCollection(p5, levels)\n\n    this.takeSnapshot = () => {\n      undoSteps = Math.min(undoSteps + 1, images.amount - 1)\n      // each time we draw we disable redo\n      redoSteps = 0\n      images.next()\n      images.capture()\n    }\n\n    this.undo = () => {\n      if (undoSteps > 0) {\n        undoSteps--\n        redoSteps++\n        images.prev()\n        images.show()\n      }\n    }\n    this.redo = () => {\n      if (redoSteps > 0) {\n        undoSteps++\n        redoSteps--\n        images.next()\n        images.show()\n      }\n    }\n  }\n}\n\nclass CircImgCollection {\n  constructor (p5, amountOfImages) {\n    let current = 0\n    let img = []\n\n    let amount = amountOfImages\n    this.amount = amount\n\n    // Initialize all images as copies of the current display\n    for (let i = 0; i < amount; i++) {\n      img[i] = p5.createImage(p5.width, p5.height)\n      img[i] = p5.get()\n    }\n\n    this.next = () => {\n      current = (current + 1) % amount\n    }\n    this.prev = () => {\n      current = (current - 1 + amount) % amount\n    }\n    this.capture = () => {\n      img[current] = p5.get()\n    }\n    this.show = () => {\n      p5.image(img[current], 0, 0)\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/sketch/undo.js"],"sourceRoot":""}